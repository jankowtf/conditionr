% Generated by roxygen2 (4.0.1): do not edit by hand
\name{signalCondition}
\alias{signalCondition}
\title{Signal Custom Condition}
\usage{
signalCondition(condition, msg = NULL, ns = NULL, call = sys.call(-2),
  type = c("message", "warning", "error", "condition"), signal = TRUE)
}
\arguments{
\item{condition}{\strong{Signature argument}.
Object containing condition information.
Usually, this is the name of a condition class that is to be used.}

\item{msg}{\code{\link{character}}. Dimension: any.
Condition message. Named components are transformed into the following
structure: \code{* <item>: <item-value>}, (e.g. "Item 1"="some message"
will become "* Item 1: some message" in the actual condition message.
The first element will be treated as the message's header.
Line numbers are automatically added beginning from the second line
(\code{[<number>] some message} or
\code{[<number>] * <item>: <item-value>}).}

\item{ns}{\code{\link{character}}.
Optional namespace.}

\item{call}{\code{\link{call}}. Dimension: 1.
System call one frame up the calling stack. This will correspond to
the closure that is spanned by the function/method that calls this
method when a condition is to be signaled.
Default: \code{sys.call(-1)}.
There should be no need to change this default value.}

\item{type}{\code{\link{character}}. Dimension: 1.
Selector for the condition type.
Choices: \code{"message"}, \code{"warning"}, \code{"error"} or
\code{"condition"}.
Default: \code{"message"}.}

\item{signal}{\code{\link{logical}}. Dimension: 1.
\code{TRUE} (default) means the condition is signaled right away,
\code{FALSE} means the condition object is returned only.}
}
\value{
Object of the class(es) that have been provided by \code{condition} and
		also inheriting from \code{\link{condition}} and depending on
		\code{type} also from \code{\link{message}}, \code{\link{warning}} or
		\code{\link{error}}.
}
\description{
Signals custom conditions.
}
\details{
The returned object will always inherit from class of object \code{condition}.
		The value of \code{condition} will always be the first entry/entries of the
		object's class graph.
		Depending on the setting of \code{type}, it also inherits from
		either \code{message}, \code{warning}, \code{error} or \code{custom}.
		If no value for \code{condition} is specified, then depending on the setting
		of \code{type} respective default values are used: \code{"DefaultMessage"},
		\code{"RappDefaultWarning"}, \code{"RappDefaultError"} and
		\code{"RappDefaultCondition"}.
}
\section{Custom messages}{

   When the first element in \code{msg} is unnamed, then it is regarded as
   the messages's header which will be appended with \code{" //"}. Otherwise,
   message elements are regarded as name-value pairs that are displayed in
   the following format: \code{"* <name>: <value>"}.
   (e.g. \code{"* Line 1: hello world!"}).
}
\examples{
\dontrun{
  
##------------------------------------------------------------------------------
## Messages 
##------------------------------------------------------------------------------

## Signaled right away //
## Note that an actuall message is issued in the console
res <- signalCondition()
class(res)

## Not signaled right away, only condition object is returned //
res <- signalCondition(signal = FALSE)
res
class(res)
## Explicit issuing:
message(res)

## Custom condition class(es) //
res <- signalCondition(condition = "CustomMessage")
class(res)
res <- signalCondition(condition = c("CustomMessage1", "CustomMessage2"))
class(res)

## Custom condition message //
## With header:
res <- signalCondition(
  condition = "CustomMessage",
  msg = c("Header", "Name with whitespace" = "test", Hello = "World!"),
  signal = FALSE
)
res
message(res)

## Without header:
res <- signalCondition(
  condition = "CustomMessage",
  msg = c("Name with whitespace" = "test", Hello = "World!"),
  signal = FALSE
)
res
message(res)

## Include namespace //
## You can use this argument in order to denote the package/namespace
## that contains the function/method/closure that produces the condition
res <- signalCondition(ns = "my.package", signal = FALSE)
res 

## Illustration of the typical use within a function/method/closure //
## Note that the name of the function/method/closure is automatically added:
foo <- function(x = TRUE) {
  if (x == TRUE) {
    return("Hello World!")  
  } else {
    signalCondition(
      condition = "ArgumentXHasValueFalse",
      msg = c(
        "Header",
        Details = "illustration of a custom condition"
      ),
      ns = "my.package", 
      type = "message"
    )
    return("Hello World!")
  }
}
foo()
foo(x = FALSE)

##------------------------------------------------------------------------------
## Warnings
##------------------------------------------------------------------------------

## Signaled right away //
## Note that an actuall warning is issued in the console
res <- signalCondition(type = "warning"), "RappDefaultWarning")
class(res)

## Not signaled, only condition object is returned //
res <- signalCondition(type = "warning", signal = FALSE)
res
class(res)
## Explicit issuing:
warning(res)

## Custom condition class(es) //
res <- signalCondition(
  condition = "CustomWarning",
  type = "warning"
)
class(res)
res <- signalCondition(
  condition = c("CustomWarning1", "CustomWarning2"),
  type = "warning"
)
class(res)

## Custom condition message //
## With header:
res <- signalCondition(
  condition = "CustomWarning",
  msg = c("Header", "Name with whitespace" = "test", Hello = "World!"),
  type = "warning",
  signal = FALSE
)
res
message(res)

## Without header:
res <- signalCondition(
  condition = "CustomWarning",
  msg = c("Name with whitespace" = "test", Hello = "World!"),
  type = "warning",
  signal = FALSE
)
res
message(res)

## Include namespace //
## You can use this argument in order to denote the package/namespace
## that contains the function/method/closure that produces the condition
res <- signalCondition(ns = "my.package", type = "warning", signal = FALSE)
res


## Illustration of the typical use within a function/method/closure //
## Note that the name of the function/method/closure is automatically added:
foo <- function(x = TRUE) {
  if (x == TRUE) {
    return("Hello World!")  
  } else {
    signalCondition(
      condition = "ArgumentXHasValueFalse",
      msg = c(
        "Header",
        Details = "illustration of a custom condition"
      ),
      ns = "my.package", 
      type = "warning"
    )
    return("Hello World!")
  }
}
foo()
foo(x = FALSE)

##------------------------------------------------------------------------------
## Errors
##------------------------------------------------------------------------------

## Signaled right away //
## Note that an actuall error is issued in the console
signalCondition(type = "error")

## Not signaled, only condition object is returned //
res <- signalCondition(type = "error", signal = FALSE)
res 
(res)
## Explicit issuing:
stop(res)

## Custom condition class(es) //
res <- signalCondition(
  condition = "CustomError", 
  type = "error",
  signal = FALSE
)
class(res)
res <- signalCondition(
  condition = c("CustomError1", "CustomError2"),
  type = "error",
  signal = FALSE
)
class(res)

## Custom condition message //
## With header:
res <- signalCondition(
  condition = "CustomError",
  msg = c("Header", "Name with whitespace" = "test", Hello = "World!"),
  type = "error",
  signal = FALSE
)
res
message(res)

## Without header:
res <- signalCondition(
  condition = "CustomError",
  msg = c("Name with whitespace" = "test", Hello = "World!"),
  type = "error",
  signal = FALSE
)
res
message(res)

## Include namespace //
## You can use this argument in order to denote the package/namespace
## that contains the function/method/closure that produces the condition
res <- signalCondition(ns = "my.package", type = "error", signal = FALSE)
res

## Illustration of the typical use within a function/method/closure //
## Note that the name of the function/method/closure is automatically added:
foo <- function(x = TRUE) {
  if (x == TRUE) {
    return("Hello World!")  
  } else {
    signalCondition(
      condition = "ArgumentXHasValueFalse",
      msg = c(
        "Header",
        Details = "illustration of a custom condition"
      ),
      ns = "my.package", 
      type = "error"
    )
  }
}
foo()
foo(x = FALSE)

}
}
\author{
Janko Thyson \email{janko.thyson@rappster.de}
}
\references{
\url{http://www.rappster.de/rapp/rapp.core.examples}
}
\seealso{
\code{
		\link[rapp.core.condition]{signalCondition-character-method},
  	\link[rapp.core.condition]{signalCondition-missing-method},
		\link[base]{condition}
}
}

